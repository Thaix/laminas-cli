{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-cli Command-line interface for Laminas projects Installation Via Composer Install the library using Composer : $ composer require laminas/laminas-cli Usage $ vendor/bin/laminas [command-name] Custom command if you want to add any command for Laminas MVC or Mezzio application just implement normal Symfony console command and add register the command for the cli: return [ 'laminas-cli' => [ 'commands' => [ 'package:command-name' => MyCommand::class, ], ], ]; Please remember that if command has some dependencies you should register also factory within the container, for example: return [ 'dependencies' => [ 'factories' => [ MyCommand::class => MyCommandFactory::class, ], ], ];","title":"Home"},{"location":"#laminas-cli","text":"Command-line interface for Laminas projects","title":"laminas-cli"},{"location":"#installation","text":"","title":"Installation"},{"location":"#usage","text":"$ vendor/bin/laminas [command-name]","title":"Usage"},{"location":"#custom-command","text":"if you want to add any command for Laminas MVC or Mezzio application just implement normal Symfony console command and add register the command for the cli: return [ 'laminas-cli' => [ 'commands' => [ 'package:command-name' => MyCommand::class, ], ], ]; Please remember that if command has some dependencies you should register also factory within the container, for example: return [ 'dependencies' => [ 'factories' => [ MyCommand::class => MyCommandFactory::class, ], ], ];","title":"Custom command"},{"location":"commands-chain/","text":"Commands chain Sometimes we want to execute another command straight after successful run of a command. Please consider the following example: MyApp\\Command\\FirstCommand.php : namespace MyApp\\Command; use Symfony\\Component\\Console\\Command\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Output\\OutputInterface; class FirstCommand extends Command { /** @var string */ protected static $defaultName = 'first-command'; protected function configure() : void { $this->setName(self::$defaultName); $this->addOption('name', null, InputOption::VALUE_REQUIRED, 'Module name'); } protected function execute(InputInterface $input, OutputInterface $output) : int { $output->writeln('First command: ' . $input->getOption('name')); return 0; } } MyApp\\Command\\SecondCommand.php : namespace MyApp\\Command; use Symfony\\Component\\Console\\Command\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Output\\OutputInterface; class SecondCommand extends Command { /** @var string */ protected static $defaultName = 'second-command'; protected function configure() : void { $this->setName(self::$defaultName); $this->addOption('module', null, InputOption::VALUE_REQUIRED, 'Module name'); } protected function execute(InputInterface $input, OutputInterface $output) : int { $output->writeln('Second command: ' . $input->getOption('module')); return 0; } } Then we need only configure the chain: namespace MyApp\\Command; return [ 'laminas-cli' => [ 'commands' => [ 'first-command' => Command\\FirstCommand::class, 'second-command' => Command\\SecondCommand::class, ], 'chains' => [ Command\\FirstCommand::class => [ Command\\SecondCommand::class => ['--name' => '--module'], ], ], ], ]; Chain configuration 'chains' => [ TriggerCommand::class => [ ChainCommand1::class => [input mapper definition between TriggerCommand and ChainCommand1], // ... ChainCommandN::class => [input mapper definition between TriggerCommand and ChainCommandN], ], ], Input mapper definition is the way how options and arguments of the trigger command should be mapped into input for the chained command. For options -- prefix should be used with names, the same how we define arguments in symfony console application. It is also possible to add additional argument or option to the next command. Just provide an array as the value, for example: [ 'name' => 'module', // adds \"module\" argument to the next command call with the value of \"name\" argument from the previous command '--mode' => '--type', // adds \"--type\" option to the next command call with the value of \"--mode\" option from the previous command ['additional-arg' => 'arg-value'], // adds \"additional-arg\" argument to the next command call with the value \"arg-value\" ['--additional-opt' => 'opt-value'], // adds \"--additional-opt\" option to the next command call with the value \"opt-value\" ], It is also possible to provide class name (string) which implements Laminas\\Cli\\Input\\Mapper\\InputMapperInterface if you need more customised mapper between input of the previous and next command. Now running vendor/bin/laminas first-command will result with: $ vendor/bin/laminas first-command --name=Foo First command: Foo Executing second-command. Do you want to continue? [Y] yes, continue [s] skip this command, [n] no, break > yes, continue Second command: Foo Please note that only successful result of the first command will trigger the second command. The final result (exit code) of the chained commands will be the result of the last executed command.","title":"Commands Chain"},{"location":"commands-chain/#commands-chain","text":"Sometimes we want to execute another command straight after successful run of a command. Please consider the following example: MyApp\\Command\\FirstCommand.php : namespace MyApp\\Command; use Symfony\\Component\\Console\\Command\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Output\\OutputInterface; class FirstCommand extends Command { /** @var string */ protected static $defaultName = 'first-command'; protected function configure() : void { $this->setName(self::$defaultName); $this->addOption('name', null, InputOption::VALUE_REQUIRED, 'Module name'); } protected function execute(InputInterface $input, OutputInterface $output) : int { $output->writeln('First command: ' . $input->getOption('name')); return 0; } } MyApp\\Command\\SecondCommand.php : namespace MyApp\\Command; use Symfony\\Component\\Console\\Command\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Output\\OutputInterface; class SecondCommand extends Command { /** @var string */ protected static $defaultName = 'second-command'; protected function configure() : void { $this->setName(self::$defaultName); $this->addOption('module', null, InputOption::VALUE_REQUIRED, 'Module name'); } protected function execute(InputInterface $input, OutputInterface $output) : int { $output->writeln('Second command: ' . $input->getOption('module')); return 0; } } Then we need only configure the chain: namespace MyApp\\Command; return [ 'laminas-cli' => [ 'commands' => [ 'first-command' => Command\\FirstCommand::class, 'second-command' => Command\\SecondCommand::class, ], 'chains' => [ Command\\FirstCommand::class => [ Command\\SecondCommand::class => ['--name' => '--module'], ], ], ], ];","title":"Commands chain"},{"location":"intro/","text":"Introduction laminas-cli is a command-line interface for Laminas projects. It provides seamless integration with Laminas MVC and Mezzio applications. It is easily extensible by custom command. Integration with component If you'd like to add integration with laminas-cli into your components you have to the following: Use laminas/laminas-cli as dev dependency: $ composer require --dev laminas/laminas-cli Add the command to the library: namespace MyNamespace\\Command; use Symfony\\Component\\Console\\Command\\Command; class MyCommand extends Command { // ... } Register your command in the container: return [ 'dependencies' => [ 'invokables' => [ MyNamespace\\Command\\MyCommand::class => MyNamespace\\Command\\MyCommand::class, ], ], ]; and register the command for the cli tool: return [ 'laminas-cli' => [ 'commands' => [ 'package:command-name' => MyNamespace\\Command\\MyCommand::class, ], ], ]; If the component is providing ConfigProvider (for Mezzio applications) please provide above inside: namespace MyNamespace; class ConfigProvider { public function __invoke() : array { return [ 'laminas-cli' => $this->getCliConfig(), 'dependencies' => $this->getDependencyConfig(), ]; } public function getCliConfig() : array { return [ 'commands' => [ 'package:command-name' => Command\\MyCommand::class, ], ]; } public function getDependencyConfig() : array { return [ 'invokables' => [ Command\\MyCommand::class => Command\\MyCommand::class, ], ]; } } In case you want also provide Module class for Laminas MVC: namespace MyNamespace; class Module { public function getConfig() : array { $configProvider = new ConfigProvider(); return [ 'laminas-cli' => $configProvider->getCliConfig(), 'service_manager' => $configProvider->getDependencyConfig(), ]; } } Integration for Other Applications - Custom DI Container laminas-cli supports Laminas MVC and Mezzio application out of the box. If you want to use the tool with different application or you have modified the default configuration and container cannot be detected automatically you can still use the laminas-cli tool. You just need configure your PSR-11 container and provide it that way the tool can detect it. Just create config/container.php file which will return an instance of PSR-11 Container and it should be detected by the tool. Usage To list all available commands run: $ vendor/bin/laminas To execute a specific command run: $ vendor/bin/laminas <command-name>","title":"Introduction"},{"location":"intro/#introduction","text":"laminas-cli is a command-line interface for Laminas projects. It provides seamless integration with Laminas MVC and Mezzio applications. It is easily extensible by custom command.","title":"Introduction"},{"location":"intro/#integration-with-component","text":"If you'd like to add integration with laminas-cli into your components you have to the following: Use laminas/laminas-cli as dev dependency: $ composer require --dev laminas/laminas-cli Add the command to the library: namespace MyNamespace\\Command; use Symfony\\Component\\Console\\Command\\Command; class MyCommand extends Command { // ... } Register your command in the container: return [ 'dependencies' => [ 'invokables' => [ MyNamespace\\Command\\MyCommand::class => MyNamespace\\Command\\MyCommand::class, ], ], ]; and register the command for the cli tool: return [ 'laminas-cli' => [ 'commands' => [ 'package:command-name' => MyNamespace\\Command\\MyCommand::class, ], ], ]; If the component is providing ConfigProvider (for Mezzio applications) please provide above inside: namespace MyNamespace; class ConfigProvider { public function __invoke() : array { return [ 'laminas-cli' => $this->getCliConfig(), 'dependencies' => $this->getDependencyConfig(), ]; } public function getCliConfig() : array { return [ 'commands' => [ 'package:command-name' => Command\\MyCommand::class, ], ]; } public function getDependencyConfig() : array { return [ 'invokables' => [ Command\\MyCommand::class => Command\\MyCommand::class, ], ]; } } In case you want also provide Module class for Laminas MVC: namespace MyNamespace; class Module { public function getConfig() : array { $configProvider = new ConfigProvider(); return [ 'laminas-cli' => $configProvider->getCliConfig(), 'service_manager' => $configProvider->getDependencyConfig(), ]; } }","title":"Integration with component"},{"location":"intro/#integration-for-other-applications-custom-di-container","text":"laminas-cli supports Laminas MVC and Mezzio application out of the box. If you want to use the tool with different application or you have modified the default configuration and container cannot be detected automatically you can still use the laminas-cli tool. You just need configure your PSR-11 container and provide it that way the tool can detect it. Just create config/container.php file which will return an instance of PSR-11 Container and it should be detected by the tool.","title":"Integration for Other Applications - Custom DI Container"},{"location":"intro/#usage","text":"To list all available commands run: $ vendor/bin/laminas To execute a specific command run: $ vendor/bin/laminas <command-name>","title":"Usage"}]}